// [변수 선언과 데이터 할당]
// 동작은 같으나 메모리에 할당되는 방식, 메모리에 적재되는 것을 보기 위해선 [1] 방식이 편하다.
// [1] 선언과 할당을 풀어 쓴 방식 
// 데이터를 자유롭게 변환하기 위해서
// 메모리를 효율적으로 관리하기 위해서
// 데이터 관점으로 본다면 문자열이 길어진다면? 'test!' 가 정~말 길다면? 초기 메모리 영역이 정~말 넓어질 것이다. 즉, 비효율적이다.
// 메모리 관점으로 본다면 변수 1만개의 숫자 1을 할당한다는 상황을 가정해보면, (let a = 1, b = 1, c = 1 ...)  1만개의 변수 공간을 확보해야함
// 변수 영역을 2바이트 1만개 = 2만 바이트, 데이터 영역 8바이트 1개 vs 8바이트 와 선언과 할당을 붙여쓴 방식 8바이트 1만개 = 8만바이트 하면 이해할 수 있다.
let str1;
str1 = 'test!';

// [2] 선언과 할당을 붙여 쓴 방식
let str2 = 'test!';


// [기본형 데이터와 참조형 데이터]
// 메모리 관점으로 보는 두 가지 주요 개념
// 변수 vs 상수
// 변수 : 변수 영역 메모리를 변경할 수 있음
// 상수 : 변수 영역 메모리를 변경할 수 없음

// 불변하다 vs 불변하지 않다. (데이터 영역)
// - 불변하다 : 데이터 영역 메모리를 변경할 수 없음
// - 불변하지 않다 : 데이터 영역 메모리를 변경할 수 있음
// [첫 번째 예시]
// let a = 8; 가정했을 때, a는 주소 (100), 8은 데이터 주소(531) 즉 100주소 = 531 이며,
// a 의 값이 9로 변경된다하면 기존 8(531) 에서 9(532)가 생성되고 할당되는 것이다. 
// a는 값이 변경되었으니 변수 영역이 되는거고.
// 그러나 8은 변경되지 않으니 불변하다고 할 수 있다. 
// [두 번째 예시]
// let a = 'abc';
// a = a + 'def'; 를 하게되면 'abc'의 데이터는 예를 든 주소 (1)에 이쓴ㄴ거고 새로운 주소에 들어간 'abcdef'(2)가 할당되는 것이다.
// 즉 'abc'는 불변하다라고 할 수 있다.
// 그렇다면 사용되지 않는 데이터는 어떻게 될까?
// JS에 가비지 컬렉터라고 쓸모없는 데이터를 수거하고 다닌다. 그렇게 메모리 관리를 한다.


// [가변값과 가변성] - 데이터 영역이 바뀌는지!
// 참조형 데이터는 별도 저장공간 (obj1을 위한 별도 공간이 필요함)
// let obj1 = {a: 1, b:'bbb'}
// 변수의 주소 1001 (예시) => obj1 / a7103 ~
// 데이터의 주소 5001,5002 (예시) => 1(5001)과 'bbb'(5002)
// 참조형 데이터 주소 7103, 7103 (예시) => a/a5001 , b/b5002
// 참조형 데이터가 불변하지 않다(가변하다)라는 이유

let obj2 = {
  a: 1,
  b: 'bbb',
}
obj2.a = 2;
// 5003번에 2를 세팅 후 7103가서 a/a5003 으로 갈아낌 (불변하지 않음)


// [중첩객체]
// let obj = {x : 3 , arr : [3,4,5]}
// 변수 주소  : | @1001 |
// 변수 데이터 : | obj@7103 ~  |
// 데이터 주소 :  | @5001 | @5002 | @5003 |
// 데이터 데이터 : |  3   |   4   |  5    |
// obj 주소   :  | @7103 | @7104 |
// obj 데이터  :  |  x/@5001    |  arr/@8104  |
// arr 주소  :  | @8104 | @8105 | @8106 |
// arr 데이터 :  | @5001 | @5002 | @5003 |    